name: Deploy App Only to EKS (No Build)

on:
  workflow_dispatch:
    inputs:
      confirm:
        description: 'Type exactly: DEPLOY APP'
        required: true

jobs:
  deploy-app:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write

    if: github.event.inputs.confirm == 'DEPLOY APP'

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      # --------------------------------------------------
      # 1. AWS + kubectl
      # --------------------------------------------------
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Connect to EKS
        run: |
          aws eks update-kubeconfig --name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ secrets.AWS_REGION }}
          echo "Connected to EKS cluster"

      # --------------------------------------------------
      # 2. Clean old conflicting resources
      # --------------------------------------------------
      - name: Cleanup Old Postgres
        run: |
          kubectl delete deployment,svc,statefulset -l app=postgres --ignore-not-found=true
          sleep 5

      # --------------------------------------------------
      # 3. Apply in strict order
      # --------------------------------------------------
      - name: Apply PVC
        run: |
          kubectl apply -f kustomise/base/storage.yaml

      - name: Apply ConfigMaps
        run: |
          kubectl apply -f kustomise/base/configmap-backend.yaml
          kubectl apply -f kustomise/base/configmap-frontend.yaml || true

      - name: Apply Secrets
        run: |
          kubectl create secret generic postgres-secret \
            --from-literal=POSTGRES_USER=${{ secrets.POSTGRES_USER }} \
            --from-literal=POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }} \
            --from-literal=POSTGRES_DB=${{ secrets.POSTGRES_DB }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Apply Postgres
        run: |
          kubectl apply -f kustomise/base/postgres.yaml
          echo "Waiting for 3 minutes for Postgres to be ready..."
          #sleep 3m  # Wait for Postgres to be ready

      - name: Apply Backend
        run: |
          kubectl apply -f kustomise/base/backend.yaml
          echo "Waiting for 3 minutes for Backend to be ready..."
          #sleep 3m  # Wait for Backend to be ready

      - name: Apply Frontend
        run: |
          kubectl apply -f kustomise/base/frontend.yaml
          echo "Waiting for 3 minutes for Frontend to be ready..."
          #sleep 3m  # Wait for Frontend to be ready

      - name: Apply Load Balancer
        run: |
          kubectl apply -f kustomise/base/frontend-lb.yaml
          echo "Waiting for 2 minutes for Load Balancer to be ready..."
          #sleep 2m  # Wait for Load Balancer to be ready

      # --------------------------------------------------
      # 4. Get NLB URL
      # --------------------------------------------------
      - name: Get NLB URL
        run: |
          echo "Waiting for Load Balancer (up to 6 min)..."
          for i in {1..36}; do
            NLB=$(kubectl get svc frontend-lb -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
            if [[ -n "$NLB" && "$NLB" != "null" ]]; then
              URL="http://$NLB"
              echo "APP_URL=$URL" >> $GITHUB_ENV
              echo "APP IS LIVE: $URL"
              break
            fi
            echo "Waiting... ($i/36)"
            sleep 10
          done
          [[ -z "${{ env.APP_URL }}" ]] && echo "APP_URL=pending" >> $GITHUB_ENV

      # --------------------------------------------------
      # 5. Wait for pods and logs
      # --------------------------------------------------
      - name: Get Pods Status and Logs
        run: |
          echo "=== Checking Pod Status ==="
          kubectl get po
          sleep 4m

          echo "=== Postgres Logs ==="
          kubectl describe deploy/postgres
          sleep 2

          echo "=== Backend Logs ==="
          kubectl describe deploy/backend
          sleep 2

          echo "=== Frontend Logs ==="
          kubectl describe deploy/frontend
          sleep 2

          echo "=== Final Pods Status ==="
          kubectl get po
          
      # --------------------------------------------------
      # 6. Final Output
      # --------------------------------------------------
      - name: Summary
        run: |
          echo "DEPLOYMENT COMPLETE"
          echo "App URL: ${{ env.APP_URL }}"
          if [[ "${{ env.APP_URL }}" == *"pending"* ]]; then
            echo "NLB still provisioning..."
          else
            echo "OPEN: ${{ env.APP_URL }}"
          fi
