name: Deploy App Only to EKS (No Build)

on:
  workflow_dispatch:
    inputs:
      confirm:
        description: 'Type exactly: DEPLOY APP'
        required: true

jobs:
  deploy-app:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write

    if: github.event.inputs.confirm == 'DEPLOY APP'

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      # --------------------------------------------------
      # 1. AWS + kubectl
      # --------------------------------------------------
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Connect to EKS
        run: |
          aws eks update-kubeconfig --name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ secrets.AWS_REGION }}
          echo "Connected to EKS cluster"

      # --------------------------------------------------
      # 2. Clean old conflicting resources
      # --------------------------------------------------
      - name: Cleanup Old Postgres
        run: |
          kubectl delete deployment,svc,statefulset -l app=postgres --ignore-not-found=true
          sleep 5

      # --------------------------------------------------
      # 3. Apply in strict order
      # --------------------------------------------------
      - name: Apply PVC
        run: |
          kubectl apply -f kustomise/base/storage.yaml

      - name: Apply ConfigMaps
        run: |
          kubectl apply -f kustomise/base/configmap-backend.yaml
          kubectl apply -f kustomise/base/configmap-frontend.yaml || true

      - name: Apply Secrets
        run: |
          kubectl create secret generic postgres-secret \
            --from-literal=POSTGRES_USER=${{ secrets.POSTGRES_USER }} \
            --from-literal=POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }} \
            --from-literal=POSTGRES_DB=${{ secrets.POSTGRES_DB }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Apply Postgres
        run: |
          kubectl apply -f kustomise/base/postgres.yaml
          sleep 2

      - name: Apply Backend
        run: |
          kubectl apply -f kustomise/base/backend.yaml
          sleep 2

      - name: Apply Frontend
        run: |
          kubectl apply -f kustomise/base/frontend.yaml
          sleep 2

      - name: Apply Load Balancer
        run: |
          kubectl apply -f kustomise/base/frontend-lb.yaml
          sleep 2

      # --------------------------------------------------
      # 4. Wait for pods and logs
      # --------------------------------------------------
      - name: Get Pods Status and Logs
        run: |
          echo "=== Checking Pod Status ==="
          kubectl get po
          sleep 2

          echo "=== Postgres Logs ==="
          kubectl logs deploy/postgres --tail=20
          sleep 2

          echo "=== Backend Logs ==="
          kubectl logs deploy/backend --tail=20
          sleep 2

          echo "=== Frontend Logs ==="
          kubectl logs deploy/frontend --tail=20
          sleep 2

          echo "=== Final Pods Status ==="
          kubectl get po
          
      # --------------------------------------------------
      # 5. Final Output
      # --------------------------------------------------
      - name: Summary
        run: |
          echo "DEPLOYMENT COMPLETE"
          echo "App URL: ${{ env.APP_URL }}"
          if [[ "${{ env.APP_URL }}" == *"pending"* ]]; then
            echo "NLB still provisioning..."
          else
            echo "OPEN: ${{ env.APP_URL }}"
          fi
