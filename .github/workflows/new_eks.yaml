name: 2. Create VPC + EKS

on:
  workflow_dispatch:
    inputs:
      confirm:
        description: 'Type: CREATE INFRA'
        required: true
        default: ''

jobs:
  create-infra:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    if: github.event.inputs.confirm == 'CREATE INFRA'

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.13.0

      # -------------------------------------------------
      # 1. CLEAN & INIT (FORCE FRESH STATE)
      # -------------------------------------------------
      - name: Terraform Init (S3 + Force Refresh)
        run: |
          cd infra/terraform/app
          rm -rf .terraform* *.tfstate*
          terraform init \
            -backend-config="bucket=${{ secrets.TF_BACKEND_BUCKET }}" \
            -backend-config="key=eks/app.tfstate" \
            -backend-config="dynamodb_table=${{ secrets.TF_BACKEND_TABLE }}" \
            -backend-config="region=${{ secrets.AWS_REGION }}" \
            -reconfigure

      # -------------------------------------------------
      # 2. TERRAFORM PLAN + APPLY (SAFE + AUTO-UNLOCK + AUTO-IMPORT)
      # -------------------------------------------------
      - name: Terraform Plan & Apply (Safe & Idempotent)
        id: tf
        run: |
          cd infra/terraform/app
          MAX_RETRY=3

          for i in $(seq 1 $MAX_RETRY); do
            echo "=== ATTEMPT $i ==="

            # PLAN FIRST
            set +e
            terraform plan \
              -var="cluster_name=${{ secrets.EKS_CLUSTER_NAME }}" \
              -detailed-exitcode > plan.log 2>&1
            PLAN_CODE=$?
            set -e

            cat plan.log

            # NO CHANGES → DONE
            if [ $PLAN_CODE -eq 0 ]; then
              echo "Infrastructure up to date"
              break
            fi

            # CHANGES → APPLY
            if [ $PLAN_CODE -eq 2 ]; then
              set +e
              terraform apply -auto-approve -var="cluster_name=${{ secrets.EKS_CLUSTER_NAME }}" > apply.log 2>&1
              APPLY_EXIT=$?
              set -e

              # LOCK ERROR → UNLOCK & RETRY
              if grep -q "Error acquiring the state lock" apply.log; then
                echo "Stale lock detected. Extracting Lock ID..."
                LOCK_ID=$(grep -o "ID: [a-f0-9-]\+" apply.log | head -1 | awk '{print $2}')
                if [[ -n "$LOCK_ID" ]]; then
                  echo "Forcing unlock: $LOCK_ID"
                  terraform force-unlock -force "$LOCK_ID" && echo "Unlocked"
                fi
                sleep 10
                continue
              fi

              # ALREADY EXISTS → IMPORT
              if grep -q "already exists" apply.log || grep -q "ResourceInUse" apply.log; then
                echo "Importing existing resources..."
                terraform import module.eks_cluster.aws_eks_cluster.this ${{ secrets.EKS_CLUSTER_NAME }} || true
                VPC_ID=$(aws ec2 describe-vpcs --filters "Name=tag:Name,Values=*techv*" --query "Vpcs[0].VpcId" --output text)
                [[ -n "$VPC_ID" ]] && terraform import module.vpc.aws_vpc.this "$VPC_ID" || true
                sleep 5
                continue
              fi

              # SUCCESS
              if [ $APPLY_EXIT -eq 0 ]; then
                echo "Apply succeeded"
                break
              fi
            fi

            echo "Retry $i failed. Waiting..."
            sleep 15
          done

          # FINAL CHECK
          if [ $i -gt $MAX_RETRY ]; then
            echo "Max retries exceeded"
            cat plan.log apply.log
            exit 1
          fi

      # -------------------------------------------------
      # 3. WAIT FOR EKS ACTIVE
      # -------------------------------------------------
      - name: Wait for EKS Active
        run: |
          echo "Waiting for cluster to be ACTIVE..."
          for i in {1..40}; do
            STATUS=$(aws eks describe-cluster --name ${{ secrets.EKS_CLUSTER_NAME }} --query 'cluster.status' --output text 2>/dev/null)
            echo "Status: $STATUS"
            [[ "$STATUS" == "ACTIVE" ]] && break
            sleep 30
          done
          [[ "$STATUS" == "ACTIVE" ]] || exit 1
          echo "EKS ACTIVE!"

      # -------------------------------------------------
      # 4. KUBECTL + KUBECONFIG
      # -------------------------------------------------
      - name: Install kubectl & Connect
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          aws eks update-kubeconfig --name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ secrets.AWS_REGION }} --alias techv
          kubectl get nodes

      # -------------------------------------------------
      # 5. EBS CSI (IDEMPOTENT)
      # -------------------------------------------------
      - name: Install EBS CSI Driver
        run: |
          ROLE_NAME="AmazonEKS_EBS_CSI_DriverRole_${{ secrets.EKS_CLUSTER_NAME }}"
          ROLE_ARN=$(aws iam get-role --role-name "$ROLE_NAME" --query 'Role.Arn' --output text 2>/dev/null || echo "")

          if [[ -z "$ROLE_ARN" ]]; then
            OIDC_ID=$(aws eks describe-cluster --name ${{ secrets.EKS_CLUSTER_NAME }} --query "cluster.identity.oidc.issuer" --output text | cut -d'/' -f5)
            cat > trust.json <<EOF
            {
              "Version": "2012-10-17",
              "Statement": [{
                "Effect": "Allow",
                "Principal": { "Federated": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:oidc-provider/oidc.eks.${{ secrets.AWS_REGION }}.amazonaws.com/id/$OIDC_ID" },
                "Action": "sts:AssumeRoleWithWebIdentity",
                "Condition": {
                  "StringEquals": {
                    "oidc.eks.${{ secrets.AWS_REGION }}.amazonaws.com/id/$OIDC_ID:sub": "system:serviceaccount:kube-system:ebs-csi-controller-sa"
                  }
                }
              }]
            }
            EOF
            ROLE_ARN=$(aws iam create-role --role-name "$ROLE_NAME" --assume-role-policy-document file://trust.json --query 'Role.Arn' --output text)
            aws iam attach-role-policy --role-name "$ROLE_NAME" --policy-arn arn:aws:iam::aws:policy/service-role/AmazonEBSCSIDriverPolicy
          fi

          aws eks create-addon \
            --cluster-name ${{ secrets.EKS_CLUSTER_NAME }} \
            --addon-name aws-ebs-csi-driver \
            --addon-version v1.42.0 \
            --service-account-role-arn "$ROLE_ARN" \
            --resolve-conflicts=OVERWRITE || true

          sleep 300
          kubectl wait --for=condition=Available deployment/ebs-csi-controller -n kube-system --timeout=5m || true
          kubectl get pods -n kube-system -l app.kubernetes.io/name=aws-ebs-csi-driver

      # -------------------------------------------------
      # 6. SUCCESS
      # -------------------------------------------------
      - name: Success
        run: |
          echo "EKS CLUSTER READY!"
          echo "kubectl context: techv"
          echo "Next: Run '3. Deploy App'"
