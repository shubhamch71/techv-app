name: 3. Deploy App to K8s (Deploy + Local Access)

on:
  workflow_dispatch:
    inputs:
      confirm:
        description: 'Type: DEPLOY APP'
        required: true

jobs:
  deploy-app:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write

    if: github.event.inputs.confirm == 'DEPLOY APP'

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      # --------------------------------------------------
      # 1. Configure AWS Credentials
      # --------------------------------------------------
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      # --------------------------------------------------
      # 2. Install kubectl
      # --------------------------------------------------
      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          echo "kubectl installed"

      # --------------------------------------------------
      # 3. Update kubeconfig
      # --------------------------------------------------
      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ secrets.AWS_REGION }} --alias techv
          echo "Connected to EKS: ${{ secrets.EKS_CLUSTER_NAME }}"

      # --------------------------------------------------
      # 4. Install Pod Identity Agent (Required for EKS 1.34+)
      # --------------------------------------------------
      # - name: Install Pod Identity Agent
      #   run: |
      #     echo "Installing Pod Identity Agent..."
      #     aws eks create-addon \
      #       --cluster-name ${{ secrets.EKS_CLUSTER_NAME }} \
      #       --addon-name eks-pod-identity-agent \
      #       --resolve-conflicts=OVERWRITE \
      #       || echo "Pod Identity Agent already installed"

      #     echo "Waiting for Pod Identity Agent..."
      #     kubectl wait --for=condition=Available deployment \
      #       -n kube-system eks-pod-identity-agent --timeout=120s
      #     echo "Pod Identity Agent READY"

      # --------------------------------------------------
      # 5. Create IAM Role for EBS CSI (IRSA / Pod Identity)
      # --------------------------------------------------
      # - name: Create EBS CSI IAM Role (Idempotent)
      #   run: |
      #     echo "Setting up IAM Role for EBS CSI..."

      #     # Get OIDC Issuer
      #     OIDC_ID=$(aws eks describe-cluster \
      #       --name ${{ secrets.EKS_CLUSTER_NAME }} \
      #       --query "cluster.identity.oidc.issuer" \
      #       --output text | cut -d '/' -f 5)
      #     OIDC_URL="arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:oidc-provider/oidc.eks.${{ secrets.AWS_REGION }}.amazonaws.com/id/$OIDC_ID"

      #     # Trust Policy JSON
      #     cat > ebs-trust-policy.json << EOF
      #     {
      #       "Version": "2012-10-17",
      #       "Statement": [
      #         {
      #           "Effect": "Allow",
      #           "Principal": {
      #             "Federated": "$OIDC_URL"
      #           },
      #           "Action": "sts:AssumeRoleWithWebIdentity",
      #           "Condition": {
      #             "StringEquals": {
      #               "oidc.eks.${{ secrets.AWS_REGION }}.amazonaws.com/id/$OIDC_ID:aud": "sts.amazonaws.com",
      #               "oidc.eks.${{ secrets.AWS_REGION }}.amazonaws.com/id/$OIDC_ID:sub": "system:serviceaccount:kube-system:ebs-csi-controller-sa"
      #             }
      #           }
      #         }
      #       ]
      #     }
      #     EOF

      #     # Create or reuse role
      #     ROLE_NAME="AmazonEKS_EBS_CSI_DriverRole_${{ secrets.EKS_CLUSTER_NAME }}"
      #     ROLE_ARN=$(aws iam get-role --role-name "$ROLE_NAME" --query 'Role.Arn' --output text 2>/dev/null || echo "")

      #     if [[ -z "$ROLE_ARN" ]]; then
      #       echo "Creating IAM role: $ROLE_NAME"
      #       ROLE_ARN=$(aws iam create-role \
      #         --role-name "$ROLE_NAME" \
      #         --assume-role-policy-document file://ebs-trust-policy.json \
      #         --query 'Role.Arn' --output text)
      #       echo "Role created: $ROLE_ARN"
      #     else
      #       echo "Using existing role: $ROLE_ARN"
      #     fi

      #     # Attach AWS managed policy
      #     aws iam attach-role-policy \
      #       --policy-arn arn:aws:iam::aws:policy/service-role/AmazonEBSCSIDriverPolicy \
      #       --role-name "$ROLE_NAME" \
      #       || echo "Policy already attached"

      #     echo "ROLE_ARN=$ROLE_ARN" >> $GITHUB_ENV

      # # --------------------------------------------------
      # # 6. Install EBS CSI Driver Add-on
      # # --------------------------------------------------
      # - name: Install EBS CSI Driver
      #   run: |
      #     echo "Installing EBS CSI Driver..."
      #     aws eks create-addon \
      #       --cluster-name ${{ secrets.EKS_CLUSTER_NAME }} \
      #       --addon-name aws-ebs-csi-driver \
      #       --service-account-role-arn ${{ env.ROLE_ARN }} \
      #       --resolve-conflicts=OVERWRITE \
      #       || echo "EBS CSI already installed"

      #     echo "Waiting for EBS CSI Controller..."
      #     kubectl wait --for=condition=Available deployment \
      #       -n kube-system ebs-csi-controller --timeout=180s
      #     echo "EBS CSI DRIVER READY! PVCs can now be provisioned"

      # --------------------------------------------------
      # 7. Create Dynamic Postgres Secret (No Git Hardcode)
      # --------------------------------------------------
      - name: Create Postgres Secret
        run: |
          echo "Creating secure Postgres secret..."
          kubectl delete secret postgres-secret --ignore-not-found=true
          kubectl create secret generic postgres-secret \
            --from-literal=POSTGRES_USER=postgres \
            --from-literal=POSTGRES_PASSWORD=techv@125 \
            --from-literal=POSTGRES_DB=employees \
            --dry-run=client -o yaml | kubectl apply -f -
          echo "Postgres secret applied"

      # --------------------------------------------------
      # 8. Apply K8s Resources (Strict Dependency Order)
      # --------------------------------------------------
      - name: Apply K8s Resources
        run: |
          echo "Applying Kubernetes resources in order..."

          # 1. StorageClass + PVC
          kubectl apply -f kustomise/base/storage.yaml
          echo "StorageClass + PVC applied"

          # 2. ConfigMaps
          kubectl apply -f kustomise/base/configmap-backend.yaml
          kubectl apply -f kustomise/base/configmap-frontend.yaml
          echo "ConfigMaps applied"

          # 3. Postgres
          kubectl apply -f kustomise/base/postgres.yaml
          echo "Postgres deployment applied"

          # Wait for PVC to bind
          echo "Waiting for PVC to bind (GP3 volume provisioning)..."
          kubectl wait --for=condition=Bound pvc/postgres-pvc --timeout=180s
          echo "PVC BOUND!"

          # Wait for Postgres pod
          echo "Waiting for Postgres pod to be Ready..."
          #kubectl wait --for=condition=Ready pod -l app=postgres --timeout=180s
          echo "POSTGRES IS LIVE!"

          # 4. Backend
          kubectl apply -f kustomise/base/backend.yaml
          echo "Backend applied"

          # 5. Frontend + LB
          kubectl apply -f kustomise/base/frontend.yaml
          kubectl apply -f kustomise/base/frontend-lb.yaml
          kubectl get po 
          sleep 1m
          kubectl get po 
          kubectl logs deploy/postgres
          kubectl get po 
          kubectl describe deploy/postgres
          kubectl logs deploy/backend
          kubectl describe deploy/backend
          kubectl get po 
          kubectl logs deploy/frontend
          kubectl describe deploy/frontend
          echo "Frontend + NLB applied"

          sleep 2m

          # Final status
          echo ""
          echo "=== FINAL STATUS ==="
          kubectl get po,svc,pvc -o wide

      # --------------------------------------------------
      # 9. Wait for NLB URL
      # --------------------------------------------------
      - name: Get App URL
        run: |
          echo "Waiting for NLB to be provisioned..."
          for i in {1..30}; do
            NLB=$(kubectl get svc frontend-lb -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
            if [[ -n "$NLB" && "$NLB" != "null" ]]; then
              URL="http://$NLB"
              echo "APP_URL=$URL" >> $GITHUB_ENV
              echo "APP IS LIVE: $URL"
              break
            fi
            echo "Waiting... ($i/30)"
            sleep 10
          done

          if [[ -z "${{ env.APP_URL }}" ]]; then
            echo "APP_URL=pending (NLB still provisioning)" >> $GITHUB_ENV
          fi

      # --------------------------------------------------
      # 10. Upload kubeconfig for Local Access
      # --------------------------------------------------
      - name: Generate kubeconfig for Local Access
        run: |
          mkdir -p ~/.kube
          aws eks update-kubeconfig \
            --name ${{ secrets.EKS_CLUSTER_NAME }} \
            --region ${{ secrets.AWS_REGION }} \
            --kubeconfig ./kubeconfig.yaml
          echo "kubeconfig ready for download"

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: kubeconfig
          path: ./kubeconfig.yaml
          retention-days: 1

      # --------------------------------------------------
      # 11. Final Summary
      # --------------------------------------------------
      - name: Deployment Summary
        run: |
          echo ""
          echo "DEPLOYMENT SUCCESSFUL!"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "App URL: ${{ env.APP_URL }}"
          if [[ "${{ env.APP_URL }}" == *"pending"* ]]; then
            echo "NLB still provisioning (wait 1-2 mins)..."
          else
            echo "OPEN IN BROWSER: ${{ env.APP_URL }}"
          fi
          echo ""
          echo "LOCAL ACCESS INSTRUCTIONS:"
          echo "1. Download 'kubeconfig' from Artifacts"
          echo "2. Run on your laptop:"
          echo "   export KUBECONFIG=~/Downloads/kubeconfig"
          echo "   kubectl get pods"
          echo "   kubectl port-forward svc/frontend-lb 3000:80"
          echo "   → Open http://localhost:3000"
          echo ""
          echo "All systems go!"
